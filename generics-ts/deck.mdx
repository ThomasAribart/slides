import {
  CodeSurfer,
  CodeSurferColumns,
  Step
} from 'code-surfer'
import {
  github,
  vsDark,
  nightOwl
} from '@code-surfer/themes'
import vennDiagrams from './vennDiagrams.png'
import youngExperiment from './Double_fentes.png'

export const theme = nightOwl

# Voyage au pays des g√©n√©riques

---

# Moi

Theodo, free-lance
Fullstack: TypeScript, Serverless

---

# Libraries

- JSON-Schema-to-ts
- DynamoDB-Toolbox
- Castore

---

#1

# ü§î Qu‚Äôest-ce qu‚Äôun type g√©n√©rique ?

---

<CodeSurfer>

```ts
type Contained = { value: unknown }
```

```ts
type Contained = { value: unknown }

type Contained<VALUE> = { value: VALUE }
```

```ts
type Contained = { value: unknown }

type Contained<VALUE> = { value: VALUE }

type Str = Contained<string> // { value: string }
type Num = Contained<number> // { value: number }
```

<!-- prettier-ignore -->
```ts
type Contained<
  VALUE extends string | number = "default"
> = { value: VALUE }

type Str = Contained<string> // { value: string }
type Num = Contained<number> // { value: number }
```

</CodeSurfer>

---

Pourquoi utiliser des g√©n√©riques ?

- DRY

---

#1 (bis)

# ü§î Qu‚Äôest-ce qu‚Äôune <span style={{ color: "#7FDBCA" }}>fonction</span> g√©n√©rique ?

---

<CodeSurfer>

```ts
const contain = (value: unknown): Contained => ({ value })
```

```ts
const contain = (value: unknown): Contained => ({ value })

contain('foo') // { value: unknown }
```

```ts
const contain = <VALUE>(
  value: VALUE
): Contained<VALUE> => ({ value })

contain('foo') // { value: unknown }
```

```diff 1[17:24],2,3[1:2]

```

```diff 3[4:19]

```

```ts
const contain = <VALUE>(
  value: VALUE
): Contained<VALUE> => ({ value })

contain<'foo'>('foo')
// { value: 'foo' }
```

```diff 5[1:7,15:21],6

```

```ts 5,6
const contain = <VALUE>(
  value: VALUE
): Contained<VALUE> => ({ value })

contain('foo')
// { value: 'foo' }
```

</CodeSurfer>

<Notes>

Le type g√©n√©rique va √™tre appliqu√© aux argument, et peut √™tre utilis√© pour typer le retour de la fonction.

On obtient cette syntaxe, qui est un peu redondante. La beaut√©, c'est que TypeScript peut inf√©rer la valeur du g√©n√©rique √† partir de l'argument.

</Notes>

---

#1 (bis¬≤)

# ü§î Qu‚Äôest-ce qu‚Äôune <span style={{ color: "#7FDBCA" }}>classe</span> g√©n√©rique ?

---

<CodeSurfer>

```ts
class Container<KEY extends string> {
  key: KEY

  constructor(key: KEY) {
    this.key = key
  }

  contain<VALUE>(value: VALUE): { [K in KEY]: VALUE } {
    return { [this.key]: value }
  }
}
```

```diff 1[16:35],2:6

```

```diff 8[10:53]

```

```ts
class Container<KEY extends string> {
  key: KEY

  constructor(key: KEY) {
    this.key = key
  }

  contain<VALUE>(value: VALUE): { [K in KEY]: VALUE } {
    return { [this.key]: value }
  }
}

const container = new Container('value')
container.contain('foo') // { value: 'foo' }
```

</CodeSurfer>

<Notes>

Encore une fois, une fois la classe √©crite, on n'a plus besoin d'√©crire de type g√©n√©rique.

</Notes>

---

# Pourquoi utiliser des g√©n√©riques ?

- DRY
- Am√©liore consid√©rablement le type-system
- Pas besoin d'apprendre pour s'en servir

---

<CodeSurfer>

```ts
import { z } from 'zod'

const schema = z.literal('foo')
```

```ts 3,4
import { z } from 'zod'

const schema = z.literal('foo')
// z.ZodLiteral<'foo'>
```

```ts
import { z } from 'zod'
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'

const schema = z.literal('foo')
// z.ZodLiteral<'foo'>

const MyForm = () => {
  const form = useForm({
    resolver: zodResolver(schema)
  })
  // UseFormReturn<'foo'>

  return <Form {...form}>...</Form>
}
```

```ts 5[25:31],9[23:29],14[15:21]
import { z } from 'zod'
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'

const schema = z.literal<'foo'>('foo')
// z.ZodLiteral<'foo'>

const MyForm = () => {
  const form = useForm<'foo'>({
    resolver: zodResolver(schema)
  })
  // UseFormReturn<'foo'>

  return <Form<'foo'> {...form}>...</Form>
}
```

</CodeSurfer>

<Notes>

Il est tr√®s probable que vous utilisiez d√©j√† des g√©n√©riques dans votre code base

Ce qu'il se passe c'est qu'il y a des g√©n√©riques qui op√®rent sous le capot

</Notes>

---

#2

# ü§î Comment <span style={{ color: "#7FDBCA" }}>manipuler</span> des g√©n√©riques ?

<Notes>

D√©finir des g√©n√©riques, c'est pas la seule chose qu'on faire: on va voir qu'on peut aussi les transformer au passage.

</Notes>

---

# Live-coding sur un exemple concret: Le marshalling

---

<CodeSurfer>

```ts
const marshall<VALUE>: Marshall<Value> => { ... }
```

```ts
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }
```

```ts
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }

type Marshall<VALUE> = ???
```

</CodeSurfer>

---

# Let's code ü§ì

---

### Le probl√®me avec <span style={{ color: '#7FDBCA' }}>`extends`</span>

<CodeSurferColumns>

<Step>

```ts
class A extends B {
  extension: string
}
```

```ts
class B {
  base: string
}
```

</Step>

<Step>

```ts 1:4
class A {
  base: string
  extension: string
}
```

```ts
class B {
  base: string
}
```

</Step>

</CodeSurferColumns>

<Notes>

Viens du monde des classes

On voit l'extension visuellement: On agrandit quelque chose

</Notes>

---

### Le probl√®me avec <span style={{ color: '#7FDBCA' }}>`extends`</span>

### Laquelle de ces assertions est vraie ?

<CodeSurfer>

```ts
// A
type AssertA = string | number extends string ? true : false

// B
type AssertB = string extends string | number ? true : false
```

```diff 4:5

```

</CodeSurfer>

---

### Le probl√®me avec <span style={{ color: '#7FDBCA' }}>`extends`</span>

<CodeSurferColumns>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
```

<img
  src={vennDiagrams}
  style={{ opacity: 0, height: '50%', width: 'auto' }}
/>

</Step>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
 ‚áî A stricter than B
```

<img
  src={vennDiagrams}
  style={{ opacity: 0, height: '50%', width: 'auto' }}
/>

</Step>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
 ‚áî A stricter than B
 ‚áî A ‚äÜ B
```

<img
  src={vennDiagrams}
  style={{ height: '50%', width: 'auto' }}
/>

</Step>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
 ‚áî A stricter than B
 ‚áî A ‚äÜ B

‚úÖ string extends string | number
```

<img
  src={vennDiagrams}
  style={{ height: '50%', width: 'auto' }}
/>

</Step>

</CodeSurferColumns>

---

## ‚òùÔ∏è Utiliser <span style={{ color: '#7FDBCA' }}>"strict"</span> ou <span style={{ color: '#7FDBCA' }}>"loose"</span> pour qualifier vos types

<p>
  Et pas:{' '}
  <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">Big</span>
  </span>
  , <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">large</span>
  </span>, <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">small</span>
  </span>, <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">narrow</span>
  </span>...
</p>

<Notes>

Conseil: Bannir les adjectif de taille

</Notes>

---

# Est-ce qu'on a fini? ü§ì

---

<CodeSurfer>

```ts 1:3
type VALUE extends string |¬†number
// string
// number
```

```ts 1:5
type VALUE extends string |¬†number
// string
// number
// string | number
// never
```

</CodeSurfer>

<Notes>

Est-ce qu'on a couvert tous les edge cases possible?

Non il y en a une infinit√©, mais il y en a deux en particuliers qui m'int√©ressent: Lesquels?

</Notes>

---

### Que vaut <span style={{ color: '#7FDBCA' }}><code>Marshall&lt;string¬†| number&gt;</code></span>?

<CodeSurfer>

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never
```

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never

// A
type TestA = Marshall<string | number> // never

// B
type TestB = Marshall<string | number> // { S: string } | { N: number }
```

```diff 10:11

```

</CodeSurfer>

---

### <span style={{ color: '#7FDBCA' }}><code>Extends</code></span> est un peu <span style={{ color: '#7FDBCA' }}>quantique</span>

<img
  src={youngExperiment}
  style={{ background: 'blanchedalmond', padding: '100px' }}
/>

### L'√©lectron passe dans les <span style={{ color: '#7FDBCA' }}>deux fentes</span>

<Notes>

Quantique / Fentes de Young:

- Le cas double est d√©j√† g√©r√© car `string` et `number` se retrouvent
- Le cas `never` est d√©j√† g√©r√© car l‚Äô√©clatement ne g√©n√®re aucun √©l√©ment

</Notes>

---

<CodeSurfer>

```ts
(
  | string
  | number
) extends string
  ? ...
  : ...
```

```ts 1:11
(
  | string
) extends string
  ? ...
  : ...

(
  | number
) extends string
  ? ...
  : ...
```

```ts 1:7
Marshall<string>

(
  | number
) extends string
  ? ...
  : ...
```

<!-- prettier-ignore -->
```ts 1:3
Marshall<string>
| Marshall<number>
// { S: string } | { N: number }
```

</CodeSurfer>

---

### Que vaut <span style={{ color: '#7FDBCA' }}><code>Marshall&lt;never&gt;</code></span>?

<CodeSurfer>

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never
```

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never

// A
type TestA = Marshall<never> // never

// B
type TestB = Marshall<never> // { S: never } | { N: never }
```

```ts 7:9
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never

// A
type TestA = Marshall<never> // never
// ...car la distributivit√© renvoie ‚àÖ !

// B
type TestB = Marshall<never> // { S: never } | { N: never }
```

</CodeSurfer>

---

### Pour <span style={{ color: '#7FDBCA' }}>opt out</span> de la distributiv√©:

<CodeSurfer>

```ts
// Distribu√©
type Type<VALUE> = VALUE extends A ? B : C

// üôÖ‚Äç‚ôÇÔ∏è Non-distribu√©
type Type<VALUE> = [VALUE] extends [A] ? B : C

// üôÖ‚Äç‚ôÇÔ∏è Non-distribu√©
type Type<VALUE> = { a: VALUE } extends { a: A } ? B : C
```

</CodeSurfer>

<Notes>

Il y a donc une diff√©rence entre `{ key: value } extends { key: string }` et `value extends string` !

</Notes>

---

# Oui! On a fini üéâ

---

#3

# Aller plus loin: La <span style={{ color: "#7FDBCA" }}>r√©cursion</span> üòµ‚Äçüí´

---

<CodeSurfer>

```ts
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }
```

```ts 1,6:10
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }

marshall({ foo: 42 })
// { M: { foo: Marshall<42> } }
marshall(['foo', 42])
// { L: [Marshall<'foo'>, Marshall<42>] }
```

</CodeSurfer>

<Notes>

Pour l'instant on a cod√© marshall sur des valeurs litt√©rales. Le marshalling est r√©cursif.

</Notes>

---

# Let's code ü§ì

---

#4

# Quelques <span style={{ color: "#7FDBCA" }}>warnings</span> ‚ö†Ô∏è

---

# TS a encore du mal √† lier le typage est le code

<CodeSurfer>

```ts
const marshall = <VALUE extends string | number>(
  value: VALUE
): Marshall<VALUE> => {
  if (typeof value === 'string') {
    return { S: value } // ‚ùå Fails
  }

  return ...
}
```

</CodeSurfer>

---

### Contravariance

Exemple avec le validateur
