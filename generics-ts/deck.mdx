import {
  CodeSurfer,
  CodeSurferColumns,
  Step
} from 'code-surfer'
import {
  github,
  vsDark,
  nightOwl
} from '@code-surfer/themes'
import vennDiagrams from './vennDiagrams.png'
import youngExperiment from './Double_fentes.png'
import voyageAuPaysDesMaths from './voyageAuPaysDesMaths.png'
import dynamodb from './dynamodb.jpg'

export const theme = nightOwl

<img
  src={voyageAuPaysDesMaths}
  style={{
    height: '30%',
    marginBottom: '100px',
    width: 'auto',
    borderRadius: '50px'
  }}
/>

# Voyage au pays des <span style={{ color: "#7FDBCA" }}>g√©n√©riques</span>

---

# Moi

Theodo, free-lance
Fullstack: TypeScript, Serverless

---

# Libraries

- JSON-Schema-to-ts
- DynamoDB-Toolbox
- Castore

---

# DynamoDB-Toolshack

---

#1

# ü§î Qu‚Äôest-ce qu‚Äôun type <span style={{ color: "#7FDBCA" }}>g√©n√©rique</span> ?

---

<CodeSurfer>

```ts
type Contained = { value: unknown }
```

```ts
type Contained = { value: unknown }

type Contained<VALUE> = { value: VALUE }
```

```ts
type Contained = { value: unknown }

type Contained<VALUE> = { value: VALUE }

type Str = Contained<string> // { value: string }
type Num = Contained<number> // { value: number }
```

<!-- prettier-ignore -->
```ts
type Contained<
  VALUE extends string | number = "default"
> = { value: VALUE }

type Str = Contained<string> // { value: string }
type Num = Contained<number> // { value: number }
```

</CodeSurfer>

<Notes>

A tout type on peut associer un type g√©n√©rique, que j'ai appel√© VALUE. On le place entre chevrons comme √ßa.

Ca nous permet de r√©-utiliser ce type dans des contextes diff√©rents.

</Notes>

---

## Pourquoi utiliser des g√©n√©riques ?

### ü§´ DRY

<h3 style={{ opacity: 0.5 }}>?</h3>

<h3 style={{ opacity: 0.5 }}>?</h3>

---

#1 (bis)

# ü§î Qu‚Äôest-ce qu‚Äôune <span style={{ color: "#7FDBCA" }}>fonction</span> g√©n√©rique ?

---

<CodeSurfer>

```ts
const contain = (value: unknown) => ({ value })
```

```ts
const contain = (value: unknown) => ({ value })

contain('foo') // { value: unknown }
```

```ts
const contain = <VALUE>(
  value: VALUE
): Contained<VALUE> => ({ value })

contain('foo') // { value: unknown }
```

```diff 1[17:24],2,3[1:2]

```

```diff 3[4:19]

```

```ts
const contain = <VALUE>(
  value: VALUE
): Contained<VALUE> => ({ value })

contain<'foo'>('foo')
// { value: 'foo' }
```

```diff 5[1:7,15:21],6

```

```ts 5,6
const contain = <VALUE>(
  value: VALUE
): Contained<VALUE> => ({ value })

contain('foo')
// { value: 'foo' }
```

</CodeSurfer>

<Notes>

J'ai √©crit ici une fonction toute simple qui prend une valeur et la met dans un objet.

Le type g√©n√©rique va venir s'appliquer aux argument, et peut √™tre utilis√© pour typer le retour de la fonction.

On obtient cette syntaxe, qui est un peu redondante. La beaut√©, c'est que TypeScript peut inf√©rer la valeur du g√©n√©rique √† partir de l'argument.

</Notes>

---

#1 (bis¬≤)

# ü§î Qu‚Äôest-ce qu‚Äôune <span style={{ color: "#7FDBCA" }}>classe</span> g√©n√©rique ?

---

<CodeSurfer>

```ts
class Container<KEY extends string> {
  key: KEY

  constructor(key: KEY) {
    this.key = key
  }

  contain<VALUE>(value: VALUE): { [K in KEY]: VALUE } {
    return { [this.key]: value }
  }
}
```

```diff 1[16:35],2:6

```

```diff 8[10:53]

```

```ts
class Container<KEY extends string> {
  key: KEY

  constructor(key: KEY) {
    this.key = key
  }

  contain<VALUE>(value: VALUE): { [K in KEY]: VALUE } {
    return { [this.key]: value }
  }
}

const container = new Container('value')
container.contain('foo') // { value: 'foo' }
```

</CodeSurfer>

<Notes>

Encore une fois, une fois la classe √©crite, on n'a plus besoin d'√©crire de type g√©n√©rique.

</Notes>

---

## Pourquoi utiliser des g√©n√©riques ?

### ü§´ DRY

### üåà Am√©liore grandement le type-system

<h3 style={{ opacity: 0.5 }}>?</h3>

---

## Pourquoi utiliser des g√©n√©riques ?

### ü§´ DRY

### üåà Am√©liore grandement le type-system

### üôà ...sans m√™me que vous ayez besoin de le savoir

---

<CodeSurfer>

```ts
import { z } from 'zod'

const schema = z.literal('foo')
```

```ts 3,4
import { z } from 'zod'

const schema = z.literal('foo')
// z.ZodLiteral<'foo'>
```

```ts
import { z } from 'zod'
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'

const schema = z.literal('foo')
// z.ZodLiteral<'foo'>

const MyForm = () => {
  const form = useForm({
    resolver: zodResolver(schema)
  })
  // UseFormReturn<'foo'>

  return <Form {...form}>...</Form>
}
```

```ts 5[25:31],9[23:29],14[15:21]
import { z } from 'zod'
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'

const schema = z.literal<'foo'>('foo')
// z.ZodLiteral<'foo'>

const MyForm = () => {
  const form = useForm<'foo'>({
    resolver: zodResolver(schema)
  })
  // UseFormReturn<'foo'>

  return <Form<'foo'> {...form}>...</Form>
}
```

</CodeSurfer>

<Notes>

Il est tr√®s probable que vous utilisiez d√©j√† des g√©n√©riques dans votre code base

Ce qu'il se passe c'est qu'il y a des g√©n√©riques qui op√®rent sous le capot

</Notes>

---

#2

# ü§î Comment <span style={{ color: "#7FDBCA" }}>manipuler</span> des g√©n√©riques ?

<Notes>

D√©finir des g√©n√©riques, c'est pas la seule chose qu'on faire: on va voir qu'on peut aussi les transformer au passage.

</Notes>

---

<img src={dynamodb} />

### Un exemple concret: Le <span style={{ color: "#7FDBCA" }}>marshalling</span>

---

<CodeSurfer>

```ts
const marshall<VALUE>: Marshall<Value> => { ... }
```

```ts
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }
```

```ts
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }

type Marshall<VALUE> = ???
```

</CodeSurfer>

<Notes>

L'exercice est le suivant: Typer une fonction Marshall qui op√®re

</Notes>

---

# Let's code ü§ì

---

### Le probl√®me avec <span style={{ color: '#7FDBCA' }}>`extends`</span>

<CodeSurferColumns>

<Step>

```ts
class A extends B {
  extension: string
}
```

```ts
class B {
  base: string
}
```

</Step>

<Step>

```ts 1:4
class A {
  base: string
  extension: string
}
```

```ts
class B {
  base: string
}
```

</Step>

</CodeSurferColumns>

<Notes>

Viens du monde des classes

On voit l'extension visuellement: On agrandit quelque chose

</Notes>

---

### Le probl√®me avec <span style={{ color: '#7FDBCA' }}>`extends`</span>

### Laquelle de ces assertions est vraie ?

<CodeSurfer>

```ts
// A
type AssertA = string | number extends string ? true : false

// B
type AssertB = string extends string | number ? true : false
```

```diff 4:5

```

</CodeSurfer>

---

### Le probl√®me avec <span style={{ color: '#7FDBCA' }}>`extends`</span>

<CodeSurferColumns>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
```

<img
  src={vennDiagrams}
  style={{ opacity: 0, height: '50%', width: 'auto' }}
/>

</Step>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
 ‚áî A stricter than B
```

<img
  src={vennDiagrams}
  style={{ opacity: 0, height: '50%', width: 'auto' }}
/>

</Step>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
 ‚áî A stricter than B
 ‚áî A ‚äÜ B
```

<img
  src={vennDiagrams}
  style={{ height: '50%', width: 'auto' }}
/>

</Step>

<Step>

```ts
A extends B
 ‚áî A has B properties and more
 ‚áî A stricter than B
 ‚áî A ‚äÜ B

‚úÖ string extends string | number
```

<img
  src={vennDiagrams}
  style={{ height: '50%', width: 'auto' }}
/>

</Step>

</CodeSurferColumns>

---

## ‚òùÔ∏è Utiliser <span style={{ color: '#7FDBCA' }}>"strict"</span> ou <span style={{ color: '#7FDBCA' }}>"loose"</span> pour qualifier vos types

<p>
  Et pas:{' '}
  <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">Big</span>
  </span>
  , <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">large</span>
  </span>, <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">small</span>
  </span>, <span style="color:red;text-decoration:line-through">
    <span style="color:#d6deeb">narrow</span>
  </span>...
</p>

<Notes>

Conseil: Bannir les adjectif de taille

</Notes>

---

# Est-ce qu'on a fini? ü§ì

---

<CodeSurfer>

```ts 1:3
type VALUE extends string |¬†number
// string
// number
```

```ts 1:5
type VALUE extends string |¬†number
// string
// number
// string | number
// never
```

</CodeSurfer>

<Notes>

Est-ce qu'on a couvert tous les edge cases possible?

Non il y en a une infinit√©, mais il y en a deux en particuliers qui m'int√©ressent: Lesquels?

</Notes>

---

### Que vaut <span style={{ color: '#7FDBCA' }}><code>Marshall&lt;string¬†| number&gt;</code></span>?

<CodeSurfer>

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never
```

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never

// A
type TestA = Marshall<string | number> // never

// B
type TestB = Marshall<string | number> // { S: string } | { N: number }
```

```diff 10:11

```

</CodeSurfer>

---

### <span style={{ color: '#7FDBCA' }}><code>Extends</code></span> est un peu <span style={{ color: '#7FDBCA' }}>quantique</span>

<img
  src={youngExperiment}
  style={{ background: 'blanchedalmond', padding: '100px' }}
/>

### Par <span style={{ color: '#7FDBCA' }}>quelle fente</span> passe l'√©lectron?

<Notes>

J'aime bien dire que extends un peu quantique. Dans l'exp√©rience des fentes de Young, on lance un √©lectron sur un √©cran opaque avec deux fentes, et on pose la question: Par quelle fente est-il pass√©?
La r√©ponse est: Les deux

- Le cas double est d√©j√† g√©r√© car `string` et `number` se retrouvent
- Le cas `never` est d√©j√† g√©r√© car l‚Äô√©clatement ne g√©n√®re aucun √©l√©ment

</Notes>

---

### <span style={{ color: '#7FDBCA' }}><code>Extends</code></span> est un peu <span style={{ color: '#7FDBCA' }}>quantique</span>

<img
  src={youngExperiment}
  style={{ background: 'blanchedalmond', padding: '100px' }}
/>

### Les <span style={{ color: '#7FDBCA' }}>deux fentes</span>!

<Notes>

J'aime bien dire que extends un peu quantique. Dans l'exp√©rience des fentes de Young, on lance un √©lectron sur un √©cran opaque avec deux fentes, et on pose la question: Par quelle fente est-il pass√©?
La r√©ponse est: Les deux

- Le cas double est d√©j√† g√©r√© car `string` et `number` se retrouvent
- Le cas `never` est d√©j√† g√©r√© car l‚Äô√©clatement ne g√©n√®re aucun √©l√©ment

</Notes>

---

<CodeSurfer>

```ts
(
  | string
  | number
) extends string
  ? ...
  : ...
```

```ts 1:11
(
  | string
) extends string
  ? ...
  : ...

(
  | number
) extends string
  ? ...
  : ...
```

```ts 1:7
Marshall<string>

(
  | number
) extends string
  ? ...
  : ...
```

<!-- prettier-ignore -->
```ts 1:3
Marshall<string>
| Marshall<number>
// { S: string } | { N: number }
```

</CodeSurfer>

<Notes>

Never mais seulement parce que la distributivit√© renvoie l'ensemble vide pas parce qu'il y a never ici

Je pourrais renvoyer toto que √ßa serait la m√™me

</Notes>

---

### Que vaut <span style={{ color: '#7FDBCA' }}><code>Marshall&lt;never&gt;</code></span>?

<CodeSurfer>

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never
```

```ts
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never

// A
type TestA = Marshall<never> // never

// B
type TestB = Marshall<never> // { S: never } | { N: never }
```

```ts 7:9
type Marshall<VALUE> = VALUE extends string
  ? { S: VALUE }
  : VALUE extends number
  ? { N: VALUE }
  : never

// A
type TestA = Marshall<never> // never
// ...car la distributivit√© renvoie ‚àÖ !

// B
type TestB = Marshall<never> // { S: never } | { N: never }
```

</CodeSurfer>

---

### Pour <span style={{ color: '#7FDBCA' }}>opt out</span> de la distributiv√©:

<CodeSurfer>

```ts
// Distribu√©
type Type<VALUE> = VALUE extends A ? B : C

// üôÖ‚Äç‚ôÇÔ∏è Non-distribu√©
type Type<VALUE> = [VALUE] extends [A] ? B : C

// üôÖ‚Äç‚ôÇÔ∏è Non-distribu√©
type Type<VALUE> = { a: VALUE } extends { a: A } ? B : C
```

</CodeSurfer>

<Notes>

Il y a donc une diff√©rence entre `{ key: value } extends { key: string }` et `value extends string` !

</Notes>

---

# Oui! On a fini üéâ

---

#3

# Aller plus loin: La <span style={{ color: "#7FDBCA" }}>r√©cursion</span> üòµ‚Äçüí´

---

<CodeSurfer>

```ts
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }
```

```ts 1,6:10
const marshall<VALUE>: Marshall<Value> => { ... }

marshall('foo') // { S: 'foo' }
marshall(42) // { N: 42 }

marshall({ foo: 42 })
// { M: { foo: Marshall<42> } }
marshall(['foo', 42])
// { L: [Marshall<'foo'>, Marshall<42>] }
```

</CodeSurfer>

<Notes>

Pour l'instant on a cod√© marshall sur des valeurs litt√©rales. Le marshalling est r√©cursif.

</Notes>

---

# Let's code ü§ì

---

#4

# Quelques <span style={{ color: "#7FDBCA" }}>warnings</span> ‚ö†Ô∏è

---

### TS <span style={{ color: "#7FDBCA" }}>ne type-checke pas</span> (encore) le JS d'un type g√©n√©rique

<CodeSurfer>

```ts
const marshall = <VALUE extends string | number>(
  value: VALUE
): Marshall<VALUE> => {
  if (typeof value === 'string') {
    return { S: value } // ‚ùå Fails
  }

  return ...
}
```

</CodeSurfer>

---

### Attention √† la <span style={{ color: "#7FDBCA" }}>contravariance</span>

<CodeSurfer>

```ts
type f = (...args: ParamsF) => ReturnF
type g = (...args: ParamsG) => ReturnG

f extends g only if...
```

```ts 1,2,5
type f = (...args: ParamsF) => ReturnF
type g = (...args: ParamsG) => ReturnG

f extends g only if...
    ...ReturnF ‚äÜ ReturnG // covariance
```

```ts 1,2,5,6
type f = (...args: ParamsF) => ReturnF
type g = (...args: ParamsG) => ReturnG

f extends g only if...
    ...ReturnF ‚äÜ ReturnG // covariance
...AND ParamsF ‚äá ParamsG // contravariance
```

</CodeSurfer>

---

### On ne peut pas <span style={{ color: "#7FDBCA" }}>r√©-utiliser</span> un type g√©n√©rique dans un type g√©n√©rique

<CodeSurfer>

```ts
const prefix = (string) => `_${string}`
const prefixMap = (strings) => strings.map(prefix)
```

```ts
const prefix = (string) => `_${string}`
const prefixMap = (strings) => strings.map(prefix)

type Prefix<STR> = `_${STR}`
// ‚ùå Not possible
type PrefixMap<STRINGS> = Map<STRINGS, Prefix>
```

```ts
const prefix = (string) => `_${string}`
const prefixMap = (strings) => strings.map(prefix)

import { Call, S, T } from 'hotscript'
type Prefix = S.Prepend<'_'>
// ‚úÖ Possible but next level üå∂Ô∏è
type PrefixMap<STRINGS> = Call<T.Map<Prefix>, STRINGS>
```

</CodeSurfer>

---

# Merci ‚ù§Ô∏è

- Re-moi
